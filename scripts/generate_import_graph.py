#!/usr/bin/env python3
"""
Generate a Mermaid flowchart of app-internal import dependencies.

Walks app/**/*.py, parses imports with ast, keeps only "app.*" internal imports,
outputs docs/architecture/IMPORT_GRAPH.mmd. Deterministic (sorted).

Usage (from repo root):
    python scripts/generate_import_graph.py
"""

import ast
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent.parent
APP_DIR = REPO_ROOT / "app"
OUTPUT_PATH = REPO_ROOT / "docs" / "architecture" / "IMPORT_GRAPH.mmd"


def module_from_path(path: Path) -> str:
    """Path under app/ -> dotted module name app.xxx.yyy."""
    rel = path.relative_to(APP_DIR)
    parts = list(rel.parts)
    if parts[-1] == "__init__.py":
        parts = parts[:-1]
    else:
        parts[-1] = parts[-1].replace(".py", "")
    return "app." + ".".join(parts)


def collect_imports() -> dict[str, set[str]]:
    """Return map: module -> set of app.* modules it imports (internal only)."""
    graph: dict[str, set[str]] = {}
    for path in sorted(APP_DIR.rglob("*.py")):
        try:
            mod = module_from_path(path)
        except ValueError:
            continue
        try:
            tree = ast.parse(path.read_text(encoding="utf-8"))
        except (SyntaxError, OSError):
            continue
        imports: set[str] = set()
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name.startswith("app."):
                        imports.add(alias.name)
            elif isinstance(node, ast.ImportFrom):
                if node.module and node.module.startswith("app."):
                    imports.add(node.module)
                elif getattr(node, "level", 0) > 0 and node.module:
                    # from .foo import ... -> resolve relative to current dir
                    pkg = path.relative_to(APP_DIR).parent
                    levels_up = getattr(node, "level", 1) - 1
                    for _ in range(levels_up):
                        pkg = pkg.parent
                    resolved = (
                        "app." + str(pkg).replace("\\", ".").replace("/", ".") + "." + node.module
                    )
                    imports.add(resolved)
                elif getattr(node, "level", 0) > 0 and not node.module:
                    # from . import x
                    pkg = path.relative_to(APP_DIR).parent
                    pkg_name = "app." + str(pkg).replace("\\", ".").replace("/", ".")
                    for alias in node.names:
                        if not alias.name.startswith("_"):
                            imports.add(f"{pkg_name}.{alias.name}")
        if imports:
            graph[mod] = imports
    return graph


def safe_id(name: str) -> str:
    """Mermaid-safe node id."""
    return name.replace(".", "_").replace("-", "_")


def main() -> None:
    graph = collect_imports()
    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    lines = [
        "%% Auto-generated by scripts/generate_import_graph.py - do not edit manually",
        "%% Run: python scripts/generate_import_graph.py",
        "",
        "flowchart LR",
    ]
    nodes = set(graph.keys())
    for imp_set in graph.values():
        nodes |= imp_set
    for n in sorted(nodes):
        if n.startswith("app."):
            label = n.replace("app.", "")
            lines.append(f'    {safe_id(n)}["{label}"]')
    for mod in sorted(graph.keys()):
        for dep in sorted(graph[mod]):
            if dep != mod and dep.startswith("app."):
                lines.append(f"    {safe_id(mod)} --> {safe_id(dep)}")
    OUTPUT_PATH.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"Wrote {OUTPUT_PATH}")


if __name__ == "__main__":
    main()
